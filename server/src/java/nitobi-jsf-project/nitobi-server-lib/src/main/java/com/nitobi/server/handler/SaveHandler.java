package com.nitobi.server.handler;

import java.util.Vector;
import java.util.ListIterator;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import com.nitobi.server.tools.XmlConverter;
import com.nitobi.server.tools.XmlRecord;
import com.nitobi.server.tools.Record;
import com.nitobi.exception.NitobiException;


/**
 * SaveHandler parses the request sent from the component on the client side
 * and separates the records that need to be inserted, updated, and deleted.
 * <p>
 * The request generated by the client-side component is in XML using a particular
 * format that is understood by SaveHandler.  Once SaveHandler has
 * been instantiated, you can access the records that need to inserted, updated, and
 * deleted and act accordingly.  Use the supplied accessor methods to access the records
 * by type.
 * </p>
 * @author Nitobi
 **/
public class SaveHandler 
{
	private Vector insertRecords;
	private Vector updateRecords;
	private Vector deleteRecords;
	private XmlConverter converter;
	
	/**
	 * Creates a SaveHandler from the request sent by the client-side component.
	 * Once instantiated, it will hold Record objects that either need to 
	 * be persisted or deleted.
	 * @param request The HttpServletRequest the SaveHandler can read the messages from the grid from.
	 * @throws NitobiException
	 */
	public SaveHandler(HttpServletRequest request) throws NitobiException
	{
		this.insertRecords = new Vector();
		this.updateRecords = new Vector();
		this.deleteRecords = new Vector();
		
		converter = new XmlConverter();
		// converter.setEbaXml(request.getReader());
		// use below to allow encoding to take effect
		try
		{
			converter.setEbaXml(request.getInputStream());
		}
		catch (java.io.IOException ex)
		{
			throw new NitobiException("Could not open the input stream from the supplied request", ex);
		}
		
		Vector updategramRecords = converter.getRecords();
		
		String[] fieldDefinitions=new String[converter.getFields().length+1];
		fieldDefinitions[0]="_recordID";
		for (int i=0; i<converter.getFields().length; i++) {
			fieldDefinitions[i+1]=converter.getFields()[i];			
		}
		
		XmlRecord xmlRecord;
		Record curRecord;		
		Vector curValues;
		for (int i = 0; i < updategramRecords.size(); i++) {
			// Get the record and the key.
			xmlRecord = (XmlRecord) updategramRecords.get(i);
			String key = xmlRecord.getKey();
			curRecord=new Record(fieldDefinitions,key);
			curValues=xmlRecord.getValues();				
			for (int j=0; j< curValues.size(); j++) {
				curRecord.setField(j+1,(String)curValues.get(j));
			}	
			// We use the xid sent from the client to uniquely identify a Record
			// regardless of "EbaType" (Inserts won't have xk, so we can't use that).
			curRecord.setField("_xid", xmlRecord.getXid());
			//curRecord.setField("xf", xmlRecord.getForeignKeyValue());
			curRecord.setForeignKeyValue(xmlRecord.getForeignKeyValue());
			if (xmlRecord.getEbaType().equals("insert")) {	
				this.insertRecords.add(curRecord);
			}
			if (xmlRecord.getEbaType().equals("update")) {				
				this.updateRecords.add(curRecord);
			}
			if (xmlRecord.getEbaType().equals("delete")) {				
				this.deleteRecords.add(curRecord);
			}
		}	
	}
	
	/**
	 * Sets the error message to be sent to the client in the response. Passing an empty string will clear the error message.
	 * @param message The error message
	 */
	public void setErrorMessage(String message) {
		converter.setErrorMessage(message);
	}
	/**
	 * Returns an Array of Records each of which has to be inserted into your data source.
	 * @return All records which need to be inserted into your data source.
	 */
	public Record[] getInsertRecords() {
		// will return all records to insert into the database
		Record[] tmp = new Record[0];
		return (Record[]) this.insertRecords.toArray(tmp);
	}
	
	/**
	 * Returns an Array of Records each of which has to be updated in your data source.
	 * @return All records which need to be updated in your data source.
	 */
	public Record[] getUpdateRecords() {
		// will return all records to insert into the database
		Record[] tmp = new Record[0];
		return (Record[]) this.updateRecords.toArray(tmp);
	}
	/**
	 * Returns an Array of Records each of which has to be deleted from your data source.
	 * @return All records which need to be deleted from your data source.
	 */
	public Record[] getDeleteRecords() {
		// will return all records to insert into the database
		Record[] tmp = new Record[0];
		return (Record[]) this.deleteRecords.toArray(tmp);
	}
	
	/**
	 * 
	 * @param xid
	 * @param key
	 */
	public void setRecordKey(String xid, String key)
	{
		Vector recs = converter.getRecords();
		ListIterator it = recs.listIterator();
		while(it.hasNext())
		{
			XmlRecord rec = (XmlRecord) it.next();
			if (xid == rec.getXid())
			{
				rec.setAttribute("xk", key);
				it.set(rec);
				break;
			}
		}
	}
	
	/**
	 * Writes back Nitobi compressed XML to the Grid and should only be called 
	 * once at the end of the SaveHandler page. This informs the Grid that 
	 * this SaveHandler has been executed correctly. Uses default encoding of UTF-8 
	 * for the XML document.
	 * @param response The response to write the compressed XML 
	 * @throws NitobiException If the response could not be written to
	 */
	public void writeToClient(HttpServletResponse response) throws NitobiException
	{
		writeToClient("UTF-8", response);
	}
	
	/**
	 * Writes back Nitobi compressed XML to the Grid and should only be called 
	 * once at the end of the SaveHandler page. This informs the Grid that 
	 * this SaveHandler has been executed correctly.
	 * @param encoding The encoding to use
	 * @param response The response to write the compressed XML 
	 * @throws NitobiException If the response could not be written to
	 */
	public void writeToClient(String encoding, HttpServletResponse response) throws NitobiException
	{
		try
		{
			response.getWriter().write(this.converter.getEbaXml(encoding));
		}
		catch (java.io.IOException ex)
		{
			throw new NitobiException("Could not write to the supplied response", ex);
		}
	}
	
	/**
	 * Returns the XmlConverter that contains XML data for the updategram.
	 * @return XmlConverter
	 */
	public XmlConverter getConverter()
	{
		return converter;
	}
}
